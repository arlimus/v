#!/usr/bin/env ruby

require "trollop"
require "mime-helpers"

opts = Trollop::options do
  opt :pretend, "Pretend, don't execute"
  opt :verbose, "Let me know what is happening."
end


class FileViewer
  include MimeHelpers

  # contains the result of parsing commandline arguments
  attr :args

  # parse arguments
  def initialize(opts)
    @opts = opts
    parseArgs
  end

  # run a given file
  # e.g. for "vid.mkv" execute "mplayer vid.mkv"
  def run( file )
    mime = getMime file
    ( puts "ee couldn't determine mime-type for file #{file}"
      return nil ) if mime.nil? or mime.empty?
    puts "-- got mime '#{mime}' for #{file}" if @opts[:verbose]
    
    runner = getRunner mime, @args
    ( puts "ee couldn't find a runner for #{mime}"
      return nil ) if runner.nil? or runner.empty?
    puts "-- got runner '#{runner}' for #{file}" if @opts[:verbose]

    exec = fillRunnerArgs runner, file, @args
    puts "++ #{exec}"
    `#{exec}` if not @opts[:pretend]
  end

  # run all files that were given as arguments
  def runAll
    @args["files"].each{|f| run f }
  end

  private

  def parseArgs
    def getArgs(&f)
      ARGV.map{|a|
        f.call(a)
      }.compact
    end

    @args = {
      "icon"    => "",
      "caption" => "v",
      "db"      => [],
      "factor"  => [],
      "files"   => []
    }
    
    @args["files"] = getArgs{ |c|
      cf = File.expand_path(c)
      File.exists?( cf ) ? cf : nil 
    }

    @args["db"] = getArgs{ |c|
      m = /^([+-][0-9]+)db$/i.match(c)
      m == nil ? nil : m[1]
    }

    @args["factor"] = getArgs{ |c|
      m = /^([0-9]+[.][0-9]+)x$/i.match(c)
      m == nil ? nil : m[1]
    }

    if @args["files"].empty?
      @args["files"] = findInterestingFilesOnCwd
    end
  end

  def findInterestingFilesOnCwd
    p "Collecting files and determining mime types..."
    files = Dir.glob "*"

    # collect all file-types into a hash
    # type => [files]
    h = {}
    files.map{|f| 
      print "."
      key = getMime( f )
      if h[key].nil? then h[key] = [] end 
      h[key].push(f)
    }
    print "\n"

    # find some combination of mime-types that fit a scheme
    keys = []
    keys = h.keys.find_all{|e| not e.index("audio").nil? } if keys.empty?
    keys = h.keys.find_all{|e| not e.index("image").nil? } if keys.empty?
    
    # collect the files from the possible mime types
    keys.empty? ? ["."] : keys.flat_map{|k| h[k]}
  end

end

FileViewer.new(opts).runAll